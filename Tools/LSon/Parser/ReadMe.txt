// == LEX TOKENIZER
EEExpEvalLex.l contains the tokenizer.  Build only the tokenizer using EEExpEvalLexBuild.bat.

// == SYNTAX
EEExpEvalParser.b contains the Bison syntax.  Build only the sytnax using EEExpEvalSyntaxBuild.bat

// == BOTH
Use EEBuildAll.bat to build both the tokenizer and the syntax parser.

// == MISC.
LSUtility.exe is executed on some files after they are copied to the final folder in order to fix some things and remove warnings.

The only files that are necessary in this directory are:
EEBuildAll.bat
EEExpEvalLex.l
EEExpEvalLexBuild.bat
EEExpEvalParser.b
EEExpEvalSyntaxBuild.bat
LSUtility.exe
ReadMe.txt


All other files are either generated or copied from the Cygwin includes directory.  They can be deleted at any time.  They will return to this directory whenever the .bat files are run.


All-in-all the class structure and the file structure of the shader language is extremely messy and hard to follow.
This is due to the messy files generated by Flex and Bison.
The code generated by these tools is extremely hard to read (things are indented randomly at places, no alignment convention, no naming conventions, etc.)
There are even comments left by the Flex/Bison team inside the code stating how messy it is.
Part of the mess involves the way things interact with each other.  I will try to break this down.

// == LEXER
The base class for the lexer is FlexLexer.h, renamed to EEExpEvalLexBase.h.
It has two classes in one file (again messy): FlexLexer and a macro yyFlexLexer.
Since this file relies on macros being set the same way to get the same resulting header file, I added a layer above that which simply defines the proper macros and then includes EEExpEvalLexBase.h.
This file is EEExpEvalLexer.h.  This is the file that should always be included when trying to get a lexer object.  Never include EEExpEvalLexBase.h directly.
EEExpEvalLexer.h defines the class CExpEvalLexer which will be needed by the parser.
EEExpEvalLexBase.cpp is generated by Flex.  Its primary header is EEExpEvalLexBase.h.
The lexer side of things is not so bad, though still confusing.

// == PARSER
Now for the Bison side of things.  Where to begin?
Bison generates EEExpEvalParser.cpp and EEExpEvalParser.hpp (renamed to EEExpEvalParser.h).
EEExpEvalParser.h is supposed to define the user section from EEExpEvalParser.b, but it doesn't.  EEExpEvalParser.b is supposed to have a union "union YYSTYPE", and that union is supposed to be inside the generated header file, as it was in older versions of Bison, but for some strange reason it is not.
See the EEExpEvalSyntaxNodes.h file.  The "enum LSG_NODE" and "union YYSTYPE" areas were supposed to be in EEExpEvalParser.b and then copied as-is to EEExpEvalParser.h when Bison is run.  Instead, the %union type and all of the tokens are declared in, but nested inside the class.  The LSG_NODE type is not copied at all.
The lexer needs the token definitions, but because of the erroneous generation from Bison it can't get them without also getting an invalid definition of LSG_SHADER_SYNTAX_NODES, since LSG_NODE won't be declared.
So EEExpEvalSyntaxNodes.h was created so that the parser could include that to get the correct union along with LSG_NODE, and when the lexer includes EEExpEvalParser.h, YYSTYPE will be defined and the lexer will not get a bad LSG_SHADER_SYNTAX_NODES.  Then EEExpEvalParser.b includes this file instead of having the union defined from within EEExpEvalParser.b.
The user section of EEExpEvalParser.b is being copied as-is to the generated .cpp file instead of to the .h file.  This seems to be an error.  The file structure could be made much more organized if this were to be fixed as it was in previous versions of Bison.

